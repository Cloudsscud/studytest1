2024\3\21

//操作符

int main()
{
	//int a = 10;//00000000000000000000000000001100
	//int b = a >> 1;//00000000000000000000000000000110  --5
	//int a = -1;
	//int b = a >> 1;// --  -1 算术移位
	//内存中存储的是补码，>>1位后，-1的补码没有发生变化(依旧全为1)
	// 
	//int a = 16;
	//int b = a >> 2;  //二的幂次右移几位，就是除以几个2
	//printf("%d", b);
	//return 0;

	// & —— 按位与 (全一则一)
	//  5 & 6 = 4
	//		101 —— 5
	//		110 —— 6
	//		100 —— 4
	// | —— 按位或 (有一则一)
	//  5 | 6 = 7
	//		101 —— 5
	//		110 —— 6
	//		111 —— 7
	// ^ —— 按位异或 (相同为零，相异为一)
	//	5 ^ 6 = 3
	//		101 —— 5
	//		110 —— 6
	//		011 —— 3

	//不创建第三个变量，实现两变量的交换
	//1)
	/*int a = 3;
	int b = 4;
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("a=%d,b=%d", a, b);
	return 0;*/
	//2)加减法——可能会溢出
	/*int a = 3;
	int b = 4;
	a = a + b;
	b = a - b;
	a = a - b;
	printf("a=%d,b=%d", a, b);
	return 0;*/

//	//求一个整数存储在内存二进制中一的个数
//	int num = 0;
//	scanf("%d", &num);
//	int count = 0;
//
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((num >> i) & 1))
//		{
//			count++;
//		}
//	}
//	printf("%d", count);
//	return 0;

	int num = 0;
	int count = 0;
	scanf("%d", &num);
	while (num)
	{
		count++;	//能进来的至少有一位是1
		num = (num & (num - 1));	//  num最右侧那个非0位（也就是1），其右侧 若有0（如1100），则其-1后，原先最右侧那个非0位变为0，其右侧的0变为1（此时如1011）；
									//再与原数（1100）&（按位与）之后，便将原数最右侧的1变为0（1000）；
									// 如果此后仍不为0（假），说明至少还有一位是1，重复该操作（每次进行该操作都会使最右侧非0位，变成一个0位），直至该数每一位都为0
									//每一次进入该循环都说明有一位是1，所以count每次都要+1
	}
	printf("%d", count);
	return 0;
}
